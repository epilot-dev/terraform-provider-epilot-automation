// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-automation/internal/sdk/internal/utils"
)

type FileConfig struct {
	SharedWithEndCustomer *bool `json:"shared_with_end_customer,omitempty"`
}

func (f FileConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FileConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *FileConfig) GetSharedWithEndCustomer() *bool {
	if f == nil {
		return nil
	}
	return f.SharedWithEndCustomer
}

type EcpConfig struct {
	FileConfig *FileConfig `json:"file_config,omitempty"`
	Origin     *string     `json:"origin,omitempty"`
	PortalID   *string     `json:"portal_id,omitempty"`
}

func (e EcpConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EcpConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EcpConfig) GetFileConfig() *FileConfig {
	if e == nil {
		return nil
	}
	return e.FileConfig
}

func (e *EcpConfig) GetOrigin() *string {
	if e == nil {
		return nil
	}
	return e.Origin
}

func (e *EcpConfig) GetPortalID() *string {
	if e == nil {
		return nil
	}
	return e.PortalID
}

type EntityOperationTriggerSchemasTypeType string

const (
	EntityOperationTriggerSchemasTypeTypeStr                       EntityOperationTriggerSchemasTypeType = "str"
	EntityOperationTriggerSchemasTypeTypeEqualsIgnoreCaseCondition EntityOperationTriggerSchemasTypeType = "EqualsIgnoreCaseCondition"
	EntityOperationTriggerSchemasTypeTypeAnythingButCondition      EntityOperationTriggerSchemasTypeType = "AnythingButCondition"
	EntityOperationTriggerSchemasTypeTypeExistsCondition           EntityOperationTriggerSchemasTypeType = "ExistsCondition"
	EntityOperationTriggerSchemasTypeTypePrefixCondition           EntityOperationTriggerSchemasTypeType = "PrefixCondition"
	EntityOperationTriggerSchemasTypeTypeSuffixCondition           EntityOperationTriggerSchemasTypeType = "SuffixCondition"
	EntityOperationTriggerSchemasTypeTypeWildcardCondition         EntityOperationTriggerSchemasTypeType = "WildcardCondition"
)

type EntityOperationTriggerSchemasType struct {
	Str                       *string                    `queryParam:"inline,name=type" union:"member"`
	EqualsIgnoreCaseCondition *EqualsIgnoreCaseCondition `queryParam:"inline,name=type" union:"member"`
	AnythingButCondition      *AnythingButCondition      `queryParam:"inline,name=type" union:"member"`
	ExistsCondition           *ExistsCondition           `queryParam:"inline,name=type" union:"member"`
	PrefixCondition           *PrefixCondition           `queryParam:"inline,name=type" union:"member"`
	SuffixCondition           *SuffixCondition           `queryParam:"inline,name=type" union:"member"`
	WildcardCondition         *WildcardCondition         `queryParam:"inline,name=type" union:"member"`

	Type EntityOperationTriggerSchemasTypeType
}

func CreateEntityOperationTriggerSchemasTypeStr(str string) EntityOperationTriggerSchemasType {
	typ := EntityOperationTriggerSchemasTypeTypeStr

	return EntityOperationTriggerSchemasType{
		Str:  &str,
		Type: typ,
	}
}

func CreateEntityOperationTriggerSchemasTypeEqualsIgnoreCaseCondition(equalsIgnoreCaseCondition EqualsIgnoreCaseCondition) EntityOperationTriggerSchemasType {
	typ := EntityOperationTriggerSchemasTypeTypeEqualsIgnoreCaseCondition

	return EntityOperationTriggerSchemasType{
		EqualsIgnoreCaseCondition: &equalsIgnoreCaseCondition,
		Type:                      typ,
	}
}

func CreateEntityOperationTriggerSchemasTypeAnythingButCondition(anythingButCondition AnythingButCondition) EntityOperationTriggerSchemasType {
	typ := EntityOperationTriggerSchemasTypeTypeAnythingButCondition

	return EntityOperationTriggerSchemasType{
		AnythingButCondition: &anythingButCondition,
		Type:                 typ,
	}
}

func CreateEntityOperationTriggerSchemasTypeExistsCondition(existsCondition ExistsCondition) EntityOperationTriggerSchemasType {
	typ := EntityOperationTriggerSchemasTypeTypeExistsCondition

	return EntityOperationTriggerSchemasType{
		ExistsCondition: &existsCondition,
		Type:            typ,
	}
}

func CreateEntityOperationTriggerSchemasTypePrefixCondition(prefixCondition PrefixCondition) EntityOperationTriggerSchemasType {
	typ := EntityOperationTriggerSchemasTypeTypePrefixCondition

	return EntityOperationTriggerSchemasType{
		PrefixCondition: &prefixCondition,
		Type:            typ,
	}
}

func CreateEntityOperationTriggerSchemasTypeSuffixCondition(suffixCondition SuffixCondition) EntityOperationTriggerSchemasType {
	typ := EntityOperationTriggerSchemasTypeTypeSuffixCondition

	return EntityOperationTriggerSchemasType{
		SuffixCondition: &suffixCondition,
		Type:            typ,
	}
}

func CreateEntityOperationTriggerSchemasTypeWildcardCondition(wildcardCondition WildcardCondition) EntityOperationTriggerSchemasType {
	typ := EntityOperationTriggerSchemasTypeTypeWildcardCondition

	return EntityOperationTriggerSchemasType{
		WildcardCondition: &wildcardCondition,
		Type:              typ,
	}
}

func (u *EntityOperationTriggerSchemasType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EntityOperationTriggerSchemasTypeTypeStr,
			Value: &str,
		})
	}

	var equalsIgnoreCaseCondition EqualsIgnoreCaseCondition = EqualsIgnoreCaseCondition{}
	if err := utils.UnmarshalJSON(data, &equalsIgnoreCaseCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EntityOperationTriggerSchemasTypeTypeEqualsIgnoreCaseCondition,
			Value: &equalsIgnoreCaseCondition,
		})
	}

	var anythingButCondition AnythingButCondition = AnythingButCondition{}
	if err := utils.UnmarshalJSON(data, &anythingButCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EntityOperationTriggerSchemasTypeTypeAnythingButCondition,
			Value: &anythingButCondition,
		})
	}

	var existsCondition ExistsCondition = ExistsCondition{}
	if err := utils.UnmarshalJSON(data, &existsCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EntityOperationTriggerSchemasTypeTypeExistsCondition,
			Value: &existsCondition,
		})
	}

	var prefixCondition PrefixCondition = PrefixCondition{}
	if err := utils.UnmarshalJSON(data, &prefixCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EntityOperationTriggerSchemasTypeTypePrefixCondition,
			Value: &prefixCondition,
		})
	}

	var suffixCondition SuffixCondition = SuffixCondition{}
	if err := utils.UnmarshalJSON(data, &suffixCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EntityOperationTriggerSchemasTypeTypeSuffixCondition,
			Value: &suffixCondition,
		})
	}

	var wildcardCondition WildcardCondition = WildcardCondition{}
	if err := utils.UnmarshalJSON(data, &wildcardCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EntityOperationTriggerSchemasTypeTypeWildcardCondition,
			Value: &wildcardCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for EntityOperationTriggerSchemasType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for EntityOperationTriggerSchemasType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(EntityOperationTriggerSchemasTypeType)
	switch best.Type {
	case EntityOperationTriggerSchemasTypeTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case EntityOperationTriggerSchemasTypeTypeEqualsIgnoreCaseCondition:
		u.EqualsIgnoreCaseCondition = best.Value.(*EqualsIgnoreCaseCondition)
		return nil
	case EntityOperationTriggerSchemasTypeTypeAnythingButCondition:
		u.AnythingButCondition = best.Value.(*AnythingButCondition)
		return nil
	case EntityOperationTriggerSchemasTypeTypeExistsCondition:
		u.ExistsCondition = best.Value.(*ExistsCondition)
		return nil
	case EntityOperationTriggerSchemasTypeTypePrefixCondition:
		u.PrefixCondition = best.Value.(*PrefixCondition)
		return nil
	case EntityOperationTriggerSchemasTypeTypeSuffixCondition:
		u.SuffixCondition = best.Value.(*SuffixCondition)
		return nil
	case EntityOperationTriggerSchemasTypeTypeWildcardCondition:
		u.WildcardCondition = best.Value.(*WildcardCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for EntityOperationTriggerSchemasType", string(data))
}

func (u EntityOperationTriggerSchemasType) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.EqualsIgnoreCaseCondition != nil {
		return utils.MarshalJSON(u.EqualsIgnoreCaseCondition, "", true)
	}

	if u.AnythingButCondition != nil {
		return utils.MarshalJSON(u.AnythingButCondition, "", true)
	}

	if u.ExistsCondition != nil {
		return utils.MarshalJSON(u.ExistsCondition, "", true)
	}

	if u.PrefixCondition != nil {
		return utils.MarshalJSON(u.PrefixCondition, "", true)
	}

	if u.SuffixCondition != nil {
		return utils.MarshalJSON(u.SuffixCondition, "", true)
	}

	if u.WildcardCondition != nil {
		return utils.MarshalJSON(u.WildcardCondition, "", true)
	}

	return nil, errors.New("could not marshal union type EntityOperationTriggerSchemasType: all fields are null")
}

type Activity struct {
	// Filter on activity type. If not specified, all activities will be matched on execution.
	// Example:
	//   1. Filter the events when an entity is updated from portal
	//     ```
	//       {
	//         "activity":{
	//           "type": ["EntityUpdatedFromPortal"]
	//         }
	//       }
	//     ```
	//   2. Filter the events when either a doc is uploaded/removed on an entity from a portal
	//     ```
	//       {
	//         "activity":{
	//           "type": ["DocUploadedFromPortal", "DocRemovedFromPortal"]
	//         }
	//       }
	//     ```
	//
	Type []EntityOperationTriggerSchemasType `json:"type,omitempty"`
}

func (a Activity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Activity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *Activity) GetType() []EntityOperationTriggerSchemasType {
	if a == nil {
		return nil
	}
	return a.Type
}

type EntityOperationTriggerOperation struct {
	Diff any `json:"diff,omitempty"`
	// Filter on operation type. If not specified, all operations will be matched on execution.
	// Example:
	//   1. Filter all the createEntity/updateEntity operations
	//   ```
	//     {
	//       "operation":{
	//         "operation": ["createEntity", "updateEntity"]
	//       }
	//     }
	//   ```
	//
	Operation []EntityOperation `json:"operation,omitempty"`
	Payload   any               `json:"payload,omitempty"`
}

func (e EntityOperationTriggerOperation) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EntityOperationTriggerOperation) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EntityOperationTriggerOperation) GetDiff() any {
	if e == nil {
		return nil
	}
	return e.Diff
}

func (e *EntityOperationTriggerOperation) GetOperation() []EntityOperation {
	if e == nil {
		return nil
	}
	return e.Operation
}

func (e *EntityOperationTriggerOperation) GetPayload() any {
	if e == nil {
		return nil
	}
	return e.Payload
}

type FilterConfig struct {
	Activity  *Activity                        `json:"activity,omitempty"`
	Operation *EntityOperationTriggerOperation `json:"operation,omitempty"`
}

func (f FilterConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FilterConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *FilterConfig) GetActivity() *Activity {
	if f == nil {
		return nil
	}
	return f.Activity
}

func (f *FilterConfig) GetOperation() *EntityOperationTriggerOperation {
	if f == nil {
		return nil
	}
	return f.Operation
}

type EntityOperationTriggerConfiguration struct {
	EcpConfig         *EcpConfig        `json:"ecp_config,omitempty"`
	ExcludeActivities []string          `json:"exclude_activities,omitempty"`
	FilterConfig      *FilterConfig     `json:"filter_config,omitempty"`
	IncludeActivities []string          `json:"include_activities,omitempty"`
	Operations        []EntityOperation `json:"operations,omitempty"`
	Schema            *string           `json:"schema,omitempty"`
}

func (e EntityOperationTriggerConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EntityOperationTriggerConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EntityOperationTriggerConfiguration) GetEcpConfig() *EcpConfig {
	if e == nil {
		return nil
	}
	return e.EcpConfig
}

func (e *EntityOperationTriggerConfiguration) GetExcludeActivities() []string {
	if e == nil {
		return nil
	}
	return e.ExcludeActivities
}

func (e *EntityOperationTriggerConfiguration) GetFilterConfig() *FilterConfig {
	if e == nil {
		return nil
	}
	return e.FilterConfig
}

func (e *EntityOperationTriggerConfiguration) GetIncludeActivities() []string {
	if e == nil {
		return nil
	}
	return e.IncludeActivities
}

func (e *EntityOperationTriggerConfiguration) GetOperations() []EntityOperation {
	if e == nil {
		return nil
	}
	return e.Operations
}

func (e *EntityOperationTriggerConfiguration) GetSchema() *string {
	if e == nil {
		return nil
	}
	return e.Schema
}

type EntityOperationTriggerType string

const (
	EntityOperationTriggerTypeEntityOperation EntityOperationTriggerType = "entity_operation"
)

func (e EntityOperationTriggerType) ToPointer() *EntityOperationTriggerType {
	return &e
}
func (e *EntityOperationTriggerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity_operation":
		*e = EntityOperationTriggerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EntityOperationTriggerType: %v", v)
	}
}

// EntityOperationTrigger - - If provides filter_config, executes an automation based on the filtered configuration when an entity event occurs.
//   - The conditions on a filter follows the event bridge patterns - `https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html`
//     | Comparison             | Example                                             | Rule syntax                                              |
//     |------------------------|-----------------------------------------------------|----------------------------------------------------------|
//     | Null                   | first_name is null                                  | `"first_name": [ null ]`                                 |
//     | Empty                  | last_name is empty                                  | `"last_name": [""]`                                      |
//     | Equals                 | email is "j.doe@email.com"                          | `"email": [ "j.doe@email.com" ]`                         |
//     | Equals (ignore case)   | first_name is "John"                                | `"first_name": [ { "equals-ignore-case": "john" } ]`     |
//     | And                    | fist_name is "John" and last_name is "Doe"          | `"first_name": [ "John" ], "last_name": ["Doe"]`         |
//     | Or                     | PaymentType is "Invoice" or "SEPA"                  | `"PaymentType": [ "invoice", "sepa"]`                    |
//     | Or (multiple fields)   | first_name is "John", or last_name is "Doe".        | `"$or": [ { "first_name": [ "John" ] }, { "last_name": [ "Doe" ] } ]` |
//     | Not                    | status is anything but "cancelled"                  | `"status": [ { "anything-but": [ "cancelled" ] } ]`      |
//     | Numeric (equals)       | Price is 100                                        | `"Price": [ { "numeric": [ "=", 100 ] } ]`               |
//     | Numeric (range)        | Price is more than 10, and less than or equal to 20 | `"Price": [ { "numeric": [ ">", 10, "<=", 20 ] } ]`      |
//     | Exists                 | ProductName exists                                  | `"ProductName": [ { "exists": true } ]`                  |
//     | Does not exist         | ProductName does not exist                          | `"ProductName": [ { "exists": false } ]`                 |
//     | Begins with            | OpportunityNumber starts with OPP-                  | `"opportunity_number": [ { "prefix": "OPP-" } ]`         |
//     | Ends with              | FileName ends with a .png extension                 | `"filename": [ { "suffix": ".png" } ]`                   |
//     | Wildcard               | search a string using a wildcard                    | `"email": [ { "wildcard": "*@doe.com" } ]`               |
//   - To run the execution on all update events
//     ```
//     {
//     "type": "filter_entity_event",
//     "configuration": {
//     "operation": {
//     "operation": ["updateEntity"]
//     }
//     }
//     }
//     ```
//   - To run the execution only when the updates are from a portal user
//     ```
//     {
//     "type": "filter_entity_event",
//     "configuration": {
//     "operation": {
//     "operation": ["updateEntity"]
//     },
//     "activity": {
//     "type": "EntityUpdatedFromPortal"
//     }
//     }
//     }
//     ```
//   - To run the execution only when there is an update on a specific attribute
//     ```
//     Only starts the automation when the email on a contact is changed
//     {
//     "type": "filter_entity_event",
//     "configuration": {
//     "operation": {
//     "operation": ["updateEntity"],
//     "payload": {
//     "_schema": ["contact"]
//     },
//     "diff": {
//     "updated": {
//     "email": [{ "exists": true }]
//     }
//     }
//     }
//     }
//     }
//     ```
//   - To run the execution only when a specific attribute is altered(created/updated/deleted)
//     ```
//     Only starts the automation when a price is altered on a contract
//     {
//     "type": "filter_entity_event",
//     "configuration": {
//     "operation": {
//     "payload": {
//     "_schema": ["contract"]
//     },
//     "diff": {
//     // Whether he first_name has been added, updated, or removed
//     $or: [
//     {
//     'added.first_name': [{ exists: true }]
//     },
//     {
//     'updated.first_name': [{ exists: true }]
//     },
//     {
//     'deleted.first_name': [{ exists: true }]
//     }
//     ]
//     }
//     }
//     }
//     }
//     ```
//   - To run the execution if an attribute is changed from one state to another
//     ```
//     Only starts the automation when the order status changes from `open_for_acceptance` to `placed`
//     {
//     "type": "filter_entity_event",
//     "configuration": {
//     "operation": {
//     "operation": ["updateEntity"],
//     "payload": {
//     "_schema": ["order"],
//     "status": ["placed"]
//     },
//     "diff": {
//     "updated": {
//     "status": ["open_for_acceptance"]
//     }
//     }
//     }
//     }
//     }
//     ```
type EntityOperationTrigger struct {
	Configuration EntityOperationTriggerConfiguration `json:"configuration"`
	ID            *string                             `json:"id,omitempty"`
	Type          EntityOperationTriggerType          `json:"type"`
}

func (e EntityOperationTrigger) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EntityOperationTrigger) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EntityOperationTrigger) GetConfiguration() EntityOperationTriggerConfiguration {
	if e == nil {
		return EntityOperationTriggerConfiguration{}
	}
	return e.Configuration
}

func (e *EntityOperationTrigger) GetID() *string {
	if e == nil {
		return nil
	}
	return e.ID
}

func (e *EntityOperationTrigger) GetType() EntityOperationTriggerType {
	if e == nil {
		return EntityOperationTriggerType("")
	}
	return e.Type
}
