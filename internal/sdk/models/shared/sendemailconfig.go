// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-automation/internal/sdk/internal/utils"
)

// DocumentType - Filter by a specific document type (e.g. document)
type DocumentType string

const (
	DocumentTypeDocument     DocumentType = "document"
	DocumentTypeText         DocumentType = "text"
	DocumentTypeImage        DocumentType = "image"
	DocumentTypeVideo        DocumentType = "video"
	DocumentTypeAudio        DocumentType = "audio"
	DocumentTypeSpreadsheet  DocumentType = "spreadsheet"
	DocumentTypePresentation DocumentType = "presentation"
	DocumentTypeFont         DocumentType = "font"
	DocumentTypeArchive      DocumentType = "archive"
	DocumentTypeApplication  DocumentType = "application"
	DocumentTypeUnknown      DocumentType = "unknown"
)

func (e DocumentType) ToPointer() *DocumentType {
	return &e
}
func (e *DocumentType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "document":
		fallthrough
	case "text":
		fallthrough
	case "image":
		fallthrough
	case "video":
		fallthrough
	case "audio":
		fallthrough
	case "spreadsheet":
		fallthrough
	case "presentation":
		fallthrough
	case "font":
		fallthrough
	case "archive":
		fallthrough
	case "application":
		fallthrough
	case "unknown":
		*e = DocumentType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentType: %v", v)
	}
}

// SendEmailConfigSourceFilter - Specify filters to match file entities related to main entity
type SendEmailConfigSourceFilter struct {
	// Filter by a specific relation attribute on the main entity
	Attribute *string `json:"attribute,omitempty"`
	// Filter by a specific document type (e.g. document)
	DocumentType *DocumentType `json:"document_type,omitempty"`
	// Match by filename. Regex syntax supported
	FilenameRegex *string `json:"filename_regex,omitempty"`
	// Limit files to maximum number (default, all matched file relations)
	Limit *int64 `json:"limit,omitempty"`
	// Filter by relation tag (label) on the main entity
	RelationTag *string `json:"relation_tag,omitempty"`
	// Picks main entity as file (only works if source entity is a file)
	Self *bool `default:"false" json:"self"`
	// Filter by a specific tag on the related file entity
	Tag *string `json:"tag,omitempty"`
}

func (s SendEmailConfigSourceFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SendEmailConfigSourceFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SendEmailConfigSourceFilter) GetAttribute() *string {
	if s == nil {
		return nil
	}
	return s.Attribute
}

func (s *SendEmailConfigSourceFilter) GetDocumentType() *DocumentType {
	if s == nil {
		return nil
	}
	return s.DocumentType
}

func (s *SendEmailConfigSourceFilter) GetFilenameRegex() *string {
	if s == nil {
		return nil
	}
	return s.FilenameRegex
}

func (s *SendEmailConfigSourceFilter) GetLimit() *int64 {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SendEmailConfigSourceFilter) GetRelationTag() *string {
	if s == nil {
		return nil
	}
	return s.RelationTag
}

func (s *SendEmailConfigSourceFilter) GetSelf() *bool {
	if s == nil {
		return nil
	}
	return s.Self
}

func (s *SendEmailConfigSourceFilter) GetTag() *string {
	if s == nil {
		return nil
	}
	return s.Tag
}

type Attachments struct {
	// Specify filters to match file entities related to main entity
	SourceFilter *SendEmailConfigSourceFilter `json:"source_filter,omitempty"`
}

func (a Attachments) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Attachments) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *Attachments) GetSourceFilter() *SendEmailConfigSourceFilter {
	if a == nil {
		return nil
	}
	return a.SourceFilter
}

type LanguageCode string

const (
	LanguageCodeDe LanguageCode = "de"
	LanguageCodeEn LanguageCode = "en"
)

func (e LanguageCode) ToPointer() *LanguageCode {
	return &e
}
func (e *LanguageCode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "de":
		fallthrough
	case "en":
		*e = LanguageCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LanguageCode: %v", v)
	}
}

type SendEmailConfig struct {
	// Include extra file attachments in sent email.
	// Attachments in email template will be sent regardless of this configuration.
	//
	Attachments []Attachments `json:"attachments,omitempty"`
	// Conditions necessary to send out email. Otherwise it will be skipped
	Conditions      []SendEmailCondition `json:"conditions,omitempty"`
	EmailTemplateID *string              `json:"email_template_id,omitempty"`
	LanguageCode    *LanguageCode        `json:"language_code,omitempty"`
	// Send an email exclusively to the portal user if they are registered on the portal.
	NotifyPortalUserOnly *bool `default:"false" json:"notify_portal_user_only"`
	// When true, it lets to send only the email by skip creating the thread & message entities.
	SkipCreatingEntities *bool `default:"false" json:"skip_creating_entities"`
	// Pause automation execution after sending email to wait for a confirmation link to be clicked.
	//
	// The email template should contain a confirmation link using the variable `{{confirmation_url}}`
	//
	WaitForConfirmation *bool `default:"false" json:"wait_for_confirmation"`
}

func (s SendEmailConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SendEmailConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SendEmailConfig) GetAttachments() []Attachments {
	if s == nil {
		return nil
	}
	return s.Attachments
}

func (s *SendEmailConfig) GetConditions() []SendEmailCondition {
	if s == nil {
		return nil
	}
	return s.Conditions
}

func (s *SendEmailConfig) GetEmailTemplateID() *string {
	if s == nil {
		return nil
	}
	return s.EmailTemplateID
}

func (s *SendEmailConfig) GetLanguageCode() *LanguageCode {
	if s == nil {
		return nil
	}
	return s.LanguageCode
}

func (s *SendEmailConfig) GetNotifyPortalUserOnly() *bool {
	if s == nil {
		return nil
	}
	return s.NotifyPortalUserOnly
}

func (s *SendEmailConfig) GetSkipCreatingEntities() *bool {
	if s == nil {
		return nil
	}
	return s.SkipCreatingEntities
}

func (s *SendEmailConfig) GetWaitForConfirmation() *bool {
	if s == nil {
		return nil
	}
	return s.WaitForConfirmation
}
