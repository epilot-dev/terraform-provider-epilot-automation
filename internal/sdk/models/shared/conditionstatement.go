// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type Operation string

const (
	OperationEquals              Operation = "equals"
	OperationNotEquals           Operation = "not_equals"
	OperationAnyOf               Operation = "any_of"
	OperationNoneOf              Operation = "none_of"
	OperationContains            Operation = "contains"
	OperationNotContains         Operation = "not_contains"
	OperationStartsWith          Operation = "starts_with"
	OperationEndsWith            Operation = "ends_with"
	OperationGreaterThan         Operation = "greater_than"
	OperationLessThan            Operation = "less_than"
	OperationGreaterThanOrEquals Operation = "greater_than_or_equals"
	OperationLessThanOrEquals    Operation = "less_than_or_equals"
	OperationIsEmpty             Operation = "is_empty"
	OperationIsNotEmpty          Operation = "is_not_empty"
	OperationEntityExists        Operation = "entity_exists"
	OperationEntityDoesNotExist  Operation = "entity_does_not_exist"
)

func (e Operation) ToPointer() *Operation {
	return &e
}
func (e *Operation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "equals":
		fallthrough
	case "not_equals":
		fallthrough
	case "any_of":
		fallthrough
	case "none_of":
		fallthrough
	case "contains":
		fallthrough
	case "not_contains":
		fallthrough
	case "starts_with":
		fallthrough
	case "ends_with":
		fallthrough
	case "greater_than":
		fallthrough
	case "less_than":
		fallthrough
	case "greater_than_or_equals":
		fallthrough
	case "less_than_or_equals":
		fallthrough
	case "is_empty":
		fallthrough
	case "is_not_empty":
		fallthrough
	case "entity_exists":
		fallthrough
	case "entity_does_not_exist":
		*e = Operation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Operation: %v", v)
	}
}

type AttributeOperation string

const (
	AttributeOperationAll     AttributeOperation = "all"
	AttributeOperationUpdated AttributeOperation = "updated"
	AttributeOperationAdded   AttributeOperation = "added"
	AttributeOperationDeleted AttributeOperation = "deleted"
)

func (e AttributeOperation) ToPointer() *AttributeOperation {
	return &e
}
func (e *AttributeOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "all":
		fallthrough
	case "updated":
		fallthrough
	case "added":
		fallthrough
	case "deleted":
		*e = AttributeOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AttributeOperation: %v", v)
	}
}

type AttributeType string

const (
	AttributeTypeString                AttributeType = "string"
	AttributeTypeText                  AttributeType = "text"
	AttributeTypeNumber                AttributeType = "number"
	AttributeTypeBoolean               AttributeType = "boolean"
	AttributeTypeDate                  AttributeType = "date"
	AttributeTypeDatetime              AttributeType = "datetime"
	AttributeTypeTags                  AttributeType = "tags"
	AttributeTypeCountry               AttributeType = "country"
	AttributeTypeEmail                 AttributeType = "email"
	AttributeTypePhone                 AttributeType = "phone"
	AttributeTypeProduct               AttributeType = "product"
	AttributeTypePrice                 AttributeType = "price"
	AttributeTypeStatus                AttributeType = "status"
	AttributeTypeRelation              AttributeType = "relation"
	AttributeTypeMultiselect           AttributeType = "multiselect"
	AttributeTypeSelect                AttributeType = "select"
	AttributeTypeRadio                 AttributeType = "radio"
	AttributeTypeRelationUser          AttributeType = "relation_user"
	AttributeTypePurpose               AttributeType = "purpose"
	AttributeTypeLabel                 AttributeType = "label"
	AttributeTypePayment               AttributeType = "payment"
	AttributeTypeRelationPaymentMethod AttributeType = "relation_payment_method"
)

func (e AttributeType) ToPointer() *AttributeType {
	return &e
}
func (e *AttributeType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "string":
		fallthrough
	case "text":
		fallthrough
	case "number":
		fallthrough
	case "boolean":
		fallthrough
	case "date":
		fallthrough
	case "datetime":
		fallthrough
	case "tags":
		fallthrough
	case "country":
		fallthrough
	case "email":
		fallthrough
	case "phone":
		fallthrough
	case "product":
		fallthrough
	case "price":
		fallthrough
	case "status":
		fallthrough
	case "relation":
		fallthrough
	case "multiselect":
		fallthrough
	case "select":
		fallthrough
	case "radio":
		fallthrough
	case "relation_user":
		fallthrough
	case "purpose":
		fallthrough
	case "label":
		fallthrough
	case "payment":
		fallthrough
	case "relation_payment_method":
		*e = AttributeType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AttributeType: %v", v)
	}
}

type ConditionStatementOrigin string

const (
	ConditionStatementOriginTrigger ConditionStatementOrigin = "trigger"
	ConditionStatementOriginAction  ConditionStatementOrigin = "action"
)

func (e ConditionStatementOrigin) ToPointer() *ConditionStatementOrigin {
	return &e
}
func (e *ConditionStatementOrigin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "trigger":
		fallthrough
	case "action":
		*e = ConditionStatementOrigin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConditionStatementOrigin: %v", v)
	}
}

type OriginType string

const (
	OriginTypeEntity       OriginType = "entity"
	OriginTypeWorkflow     OriginType = "workflow"
	OriginTypeJourneyBlock OriginType = "journey_block"
)

func (e OriginType) ToPointer() *OriginType {
	return &e
}
func (e *OriginType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		fallthrough
	case "workflow":
		fallthrough
	case "journey_block":
		*e = OriginType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OriginType: %v", v)
	}
}

type Source struct {
	Attribute           *string             `json:"attribute,omitempty"`
	AttributeOperation  *AttributeOperation `json:"attributeOperation,omitempty"`
	AttributeRepeatable *bool               `json:"attributeRepeatable,omitempty"`
	AttributeType       *AttributeType      `json:"attributeType,omitempty"`
	// The id of the action or trigger
	ID         *string                   `json:"id,omitempty"`
	Origin     *ConditionStatementOrigin `json:"origin,omitempty"`
	OriginType *OriginType               `json:"originType,omitempty"`
	// Whether to apply the operation to each item of the repeatable attribute
	RepeatableItemOp *bool   `json:"repeatableItemOp,omitempty"`
	Schema           *string `json:"schema,omitempty"`
}

func (s *Source) GetAttribute() *string {
	if s == nil {
		return nil
	}
	return s.Attribute
}

func (s *Source) GetAttributeOperation() *AttributeOperation {
	if s == nil {
		return nil
	}
	return s.AttributeOperation
}

func (s *Source) GetAttributeRepeatable() *bool {
	if s == nil {
		return nil
	}
	return s.AttributeRepeatable
}

func (s *Source) GetAttributeType() *AttributeType {
	if s == nil {
		return nil
	}
	return s.AttributeType
}

func (s *Source) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *Source) GetOrigin() *ConditionStatementOrigin {
	if s == nil {
		return nil
	}
	return s.Origin
}

func (s *Source) GetOriginType() *OriginType {
	if s == nil {
		return nil
	}
	return s.OriginType
}

func (s *Source) GetRepeatableItemOp() *bool {
	if s == nil {
		return nil
	}
	return s.RepeatableItemOp
}

func (s *Source) GetSchema() *string {
	if s == nil {
		return nil
	}
	return s.Schema
}

type ConditionStatement struct {
	ID        *string    `json:"id,omitempty"`
	Operation *Operation `json:"operation,omitempty"`
	Source    *Source    `json:"source,omitempty"`
	Values    []string   `json:"values,omitempty"`
}

func (c *ConditionStatement) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ConditionStatement) GetOperation() *Operation {
	if c == nil {
		return nil
	}
	return c.Operation
}

func (c *ConditionStatement) GetSource() *Source {
	if c == nil {
		return nil
	}
	return c.Source
}

func (c *ConditionStatement) GetValues() []string {
	if c == nil {
		return nil
	}
	return c.Values
}
