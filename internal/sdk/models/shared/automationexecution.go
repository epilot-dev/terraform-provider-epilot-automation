// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-automation/internal/sdk/internal/utils"
	"time"
)

type TriggerEventType string

const (
	TriggerEventTypeTriggerEventManual             TriggerEventType = "TriggerEventManual"
	TriggerEventTypeTriggerEventEntityActivity     TriggerEventType = "TriggerEventEntityActivity"
	TriggerEventTypeTriggerEventEntityOperation    TriggerEventType = "TriggerEventEntityOperation"
	TriggerEventTypeTriggerEventFlowAutomationTask TriggerEventType = "TriggerEventFlowAutomationTask"
)

type TriggerEvent struct {
	TriggerEventManual             *TriggerEventManual             `queryParam:"inline,name=trigger_event" union:"member"`
	TriggerEventEntityActivity     *TriggerEventEntityActivity     `queryParam:"inline,name=trigger_event" union:"member"`
	TriggerEventEntityOperation    *TriggerEventEntityOperation    `queryParam:"inline,name=trigger_event" union:"member"`
	TriggerEventFlowAutomationTask *TriggerEventFlowAutomationTask `queryParam:"inline,name=trigger_event" union:"member"`

	Type TriggerEventType
}

func CreateTriggerEventTriggerEventManual(triggerEventManual TriggerEventManual) TriggerEvent {
	typ := TriggerEventTypeTriggerEventManual

	return TriggerEvent{
		TriggerEventManual: &triggerEventManual,
		Type:               typ,
	}
}

func CreateTriggerEventTriggerEventEntityActivity(triggerEventEntityActivity TriggerEventEntityActivity) TriggerEvent {
	typ := TriggerEventTypeTriggerEventEntityActivity

	return TriggerEvent{
		TriggerEventEntityActivity: &triggerEventEntityActivity,
		Type:                       typ,
	}
}

func CreateTriggerEventTriggerEventEntityOperation(triggerEventEntityOperation TriggerEventEntityOperation) TriggerEvent {
	typ := TriggerEventTypeTriggerEventEntityOperation

	return TriggerEvent{
		TriggerEventEntityOperation: &triggerEventEntityOperation,
		Type:                        typ,
	}
}

func CreateTriggerEventTriggerEventFlowAutomationTask(triggerEventFlowAutomationTask TriggerEventFlowAutomationTask) TriggerEvent {
	typ := TriggerEventTypeTriggerEventFlowAutomationTask

	return TriggerEvent{
		TriggerEventFlowAutomationTask: &triggerEventFlowAutomationTask,
		Type:                           typ,
	}
}

func (u *TriggerEvent) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var triggerEventManual TriggerEventManual = TriggerEventManual{}
	if err := utils.UnmarshalJSON(data, &triggerEventManual, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TriggerEventTypeTriggerEventManual,
			Value: &triggerEventManual,
		})
	}

	var triggerEventEntityActivity TriggerEventEntityActivity = TriggerEventEntityActivity{}
	if err := utils.UnmarshalJSON(data, &triggerEventEntityActivity, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TriggerEventTypeTriggerEventEntityActivity,
			Value: &triggerEventEntityActivity,
		})
	}

	var triggerEventEntityOperation TriggerEventEntityOperation = TriggerEventEntityOperation{}
	if err := utils.UnmarshalJSON(data, &triggerEventEntityOperation, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TriggerEventTypeTriggerEventEntityOperation,
			Value: &triggerEventEntityOperation,
		})
	}

	var triggerEventFlowAutomationTask TriggerEventFlowAutomationTask = TriggerEventFlowAutomationTask{}
	if err := utils.UnmarshalJSON(data, &triggerEventFlowAutomationTask, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TriggerEventTypeTriggerEventFlowAutomationTask,
			Value: &triggerEventFlowAutomationTask,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for TriggerEvent", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for TriggerEvent", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(TriggerEventType)
	switch best.Type {
	case TriggerEventTypeTriggerEventManual:
		u.TriggerEventManual = best.Value.(*TriggerEventManual)
		return nil
	case TriggerEventTypeTriggerEventEntityActivity:
		u.TriggerEventEntityActivity = best.Value.(*TriggerEventEntityActivity)
		return nil
	case TriggerEventTypeTriggerEventEntityOperation:
		u.TriggerEventEntityOperation = best.Value.(*TriggerEventEntityOperation)
		return nil
	case TriggerEventTypeTriggerEventFlowAutomationTask:
		u.TriggerEventFlowAutomationTask = best.Value.(*TriggerEventFlowAutomationTask)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TriggerEvent", string(data))
}

func (u TriggerEvent) MarshalJSON() ([]byte, error) {
	if u.TriggerEventManual != nil {
		return utils.MarshalJSON(u.TriggerEventManual, "", true)
	}

	if u.TriggerEventEntityActivity != nil {
		return utils.MarshalJSON(u.TriggerEventEntityActivity, "", true)
	}

	if u.TriggerEventEntityOperation != nil {
		return utils.MarshalJSON(u.TriggerEventEntityOperation, "", true)
	}

	if u.TriggerEventFlowAutomationTask != nil {
		return utils.MarshalJSON(u.TriggerEventFlowAutomationTask, "", true)
	}

	return nil, errors.New("could not marshal union type TriggerEvent: all fields are null")
}

type AutomationExecution struct {
	Actions         []AnyAction         `json:"actions"`
	ActivityID      *string             `json:"activity_id,omitempty"`
	Conditions      []ActionCondition   `json:"conditions,omitempty"`
	CreatedAt       *time.Time          `json:"created_at,omitempty"`
	CurrentActionID *string             `json:"current_action_id,omitempty"`
	EntityID        string              `json:"entity_id"`
	EntitySnapshot  *EntityItemSnapshot `json:"entity_snapshot,omitempty"`
	ExecutionStatus *ExecutionStatus    `json:"execution_status,omitempty"`
	// ID of the Automation Flow
	FlowID   string  `json:"flow_id"`
	FlowName *string `json:"flow_name,omitempty"`
	ID       string  `json:"id"`
	OrgID    string  `json:"org_id"`
	// A unique token to resume a paused automation execution
	ResumeToken *string          `json:"resume_token,omitempty"`
	Schedules   []ActionSchedule `json:"schedules,omitempty"`
	// Additional contextual data for a bulk trigger automation. This would normally include additional entity IDs you'd need after a listener picks up an event.
	TriggerContext map[string]string `json:"trigger_context,omitempty"`
	TriggerEvent   *TriggerEvent     `json:"trigger_event,omitempty"`
	UpdatedAt      *time.Time        `json:"updated_at,omitempty"`
	// Version of the flow
	Version         *float64                  `json:"version,omitempty"`
	WorkflowContext *WorkflowExecutionContext `json:"workflow_context,omitempty"`
}

func (a AutomationExecution) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AutomationExecution) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AutomationExecution) GetActions() []AnyAction {
	if a == nil {
		return []AnyAction{}
	}
	return a.Actions
}

func (a *AutomationExecution) GetActivityID() *string {
	if a == nil {
		return nil
	}
	return a.ActivityID
}

func (a *AutomationExecution) GetConditions() []ActionCondition {
	if a == nil {
		return nil
	}
	return a.Conditions
}

func (a *AutomationExecution) GetCreatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *AutomationExecution) GetCurrentActionID() *string {
	if a == nil {
		return nil
	}
	return a.CurrentActionID
}

func (a *AutomationExecution) GetEntityID() string {
	if a == nil {
		return ""
	}
	return a.EntityID
}

func (a *AutomationExecution) GetEntitySnapshot() *EntityItemSnapshot {
	if a == nil {
		return nil
	}
	return a.EntitySnapshot
}

func (a *AutomationExecution) GetExecutionStatus() *ExecutionStatus {
	if a == nil {
		return nil
	}
	return a.ExecutionStatus
}

func (a *AutomationExecution) GetFlowID() string {
	if a == nil {
		return ""
	}
	return a.FlowID
}

func (a *AutomationExecution) GetFlowName() *string {
	if a == nil {
		return nil
	}
	return a.FlowName
}

func (a *AutomationExecution) GetID() string {
	if a == nil {
		return ""
	}
	return a.ID
}

func (a *AutomationExecution) GetOrgID() string {
	if a == nil {
		return ""
	}
	return a.OrgID
}

func (a *AutomationExecution) GetResumeToken() *string {
	if a == nil {
		return nil
	}
	return a.ResumeToken
}

func (a *AutomationExecution) GetSchedules() []ActionSchedule {
	if a == nil {
		return nil
	}
	return a.Schedules
}

func (a *AutomationExecution) GetTriggerContext() map[string]string {
	if a == nil {
		return nil
	}
	return a.TriggerContext
}

func (a *AutomationExecution) GetTriggerEvent() *TriggerEvent {
	if a == nil {
		return nil
	}
	return a.TriggerEvent
}

func (a *AutomationExecution) GetUpdatedAt() *time.Time {
	if a == nil {
		return nil
	}
	return a.UpdatedAt
}

func (a *AutomationExecution) GetVersion() *float64 {
	if a == nil {
		return nil
	}
	return a.Version
}

func (a *AutomationExecution) GetWorkflowContext() *WorkflowExecutionContext {
	if a == nil {
		return nil
	}
	return a.WorkflowContext
}
