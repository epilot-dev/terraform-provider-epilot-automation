// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-automation/internal/sdk/internal/utils"
	"time"
)

type DataType string

const (
	DataTypeArrayOfEntityRef          DataType = "arrayOfEntityRef"
	DataTypeStr                       DataType = "str"
	DataTypeArrayOfEntitySearchFilter DataType = "arrayOfEntitySearchFilter"
)

type Data struct {
	ArrayOfEntityRef          []EntityRef          `queryParam:"inline,name=data" union:"member"`
	Str                       *string              `queryParam:"inline,name=data" union:"member"`
	ArrayOfEntitySearchFilter []EntitySearchFilter `queryParam:"inline,name=data" union:"member"`

	Type DataType
}

func CreateDataArrayOfEntityRef(arrayOfEntityRef []EntityRef) Data {
	typ := DataTypeArrayOfEntityRef

	return Data{
		ArrayOfEntityRef: arrayOfEntityRef,
		Type:             typ,
	}
}

func CreateDataStr(str string) Data {
	typ := DataTypeStr

	return Data{
		Str:  &str,
		Type: typ,
	}
}

func CreateDataArrayOfEntitySearchFilter(arrayOfEntitySearchFilter []EntitySearchFilter) Data {
	typ := DataTypeArrayOfEntitySearchFilter

	return Data{
		ArrayOfEntitySearchFilter: arrayOfEntitySearchFilter,
		Type:                      typ,
	}
}

func (u *Data) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var arrayOfEntityRef []EntityRef = []EntityRef{}
	if err := utils.UnmarshalJSON(data, &arrayOfEntityRef, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DataTypeArrayOfEntityRef,
			Value: arrayOfEntityRef,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DataTypeStr,
			Value: &str,
		})
	}

	var arrayOfEntitySearchFilter []EntitySearchFilter = []EntitySearchFilter{}
	if err := utils.UnmarshalJSON(data, &arrayOfEntitySearchFilter, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DataTypeArrayOfEntitySearchFilter,
			Value: arrayOfEntitySearchFilter,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Data", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Data", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DataType)
	switch best.Type {
	case DataTypeArrayOfEntityRef:
		u.ArrayOfEntityRef = best.Value.([]EntityRef)
		return nil
	case DataTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case DataTypeArrayOfEntitySearchFilter:
		u.ArrayOfEntitySearchFilter = best.Value.([]EntitySearchFilter)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Data", string(data))
}

func (u Data) MarshalJSON() ([]byte, error) {
	if u.ArrayOfEntityRef != nil {
		return utils.MarshalJSON(u.ArrayOfEntityRef, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfEntitySearchFilter != nil {
		return utils.MarshalJSON(u.ArrayOfEntitySearchFilter, "", true)
	}

	return nil, errors.New("could not marshal union type Data: all fields are null")
}

type BulkTriggerJobType string

const (
	BulkTriggerJobTypeRefs   BulkTriggerJobType = "refs"
	BulkTriggerJobTypeQuery  BulkTriggerJobType = "query"
	BulkTriggerJobTypeFilter BulkTriggerJobType = "filter"
)

func (e BulkTriggerJobType) ToPointer() *BulkTriggerJobType {
	return &e
}
func (e *BulkTriggerJobType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "refs":
		fallthrough
	case "query":
		fallthrough
	case "filter":
		*e = BulkTriggerJobType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BulkTriggerJobType: %v", v)
	}
}

// EntityQuery - Query configuration for loading entities
type EntityQuery struct {
	Data Data               `json:"data"`
	Type BulkTriggerJobType `json:"type"`
}

func (e *EntityQuery) GetData() Data {
	if e == nil {
		return Data{}
	}
	return e.Data
}

func (e *EntityQuery) GetType() BulkTriggerJobType {
	if e == nil {
		return BulkTriggerJobType("")
	}
	return e.Type
}

type SearchAfterType string

const (
	SearchAfterTypeStr    SearchAfterType = "str"
	SearchAfterTypeNumber SearchAfterType = "number"
)

type SearchAfter struct {
	Str    *string  `queryParam:"inline,name=search_after" union:"member"`
	Number *float64 `queryParam:"inline,name=search_after" union:"member"`

	Type SearchAfterType
}

func CreateSearchAfterStr(str string) SearchAfter {
	typ := SearchAfterTypeStr

	return SearchAfter{
		Str:  &str,
		Type: typ,
	}
}

func CreateSearchAfterNumber(number float64) SearchAfter {
	typ := SearchAfterTypeNumber

	return SearchAfter{
		Number: &number,
		Type:   typ,
	}
}

func (u *SearchAfter) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SearchAfterTypeStr,
			Value: &str,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SearchAfterTypeNumber,
			Value: &number,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchAfter", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchAfter", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SearchAfterType)
	switch best.Type {
	case SearchAfterTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case SearchAfterTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchAfter", string(data))
}

func (u SearchAfter) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type SearchAfter: all fields are null")
}

// PaginationState - Pagination state for entity loading
type PaginationState struct {
	// Whether there are more entities to load
	HasMore *bool `json:"has_more,omitempty"`
	// Number of entities per page
	PageSize *int64 `json:"page_size,omitempty"`
	// Number of pages processed so far
	PagesProcessed *int64 `json:"pages_processed,omitempty"`
	// Last sort value used for pagination
	SearchAfter []SearchAfter `json:"search_after,omitempty"`
	// Stable query ID for pagination
	StableQueryID *string `json:"stable_query_id,omitempty"`
	// Total number of entities processed so far
	TotalProcessed *int64 `json:"total_processed,omitempty"`
}

func (p *PaginationState) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginationState) GetPageSize() *int64 {
	if p == nil {
		return nil
	}
	return p.PageSize
}

func (p *PaginationState) GetPagesProcessed() *int64 {
	if p == nil {
		return nil
	}
	return p.PagesProcessed
}

func (p *PaginationState) GetSearchAfter() []SearchAfter {
	if p == nil {
		return nil
	}
	return p.SearchAfter
}

func (p *PaginationState) GetStableQueryID() *string {
	if p == nil {
		return nil
	}
	return p.StableQueryID
}

func (p *PaginationState) GetTotalProcessed() *int64 {
	if p == nil {
		return nil
	}
	return p.TotalProcessed
}

// Status of the bulk trigger automation job
// * approval: Waiting for user approval to start the bulk trigger automation
// * querying_entities: Loading entities in batches
// * entities_loaded: All entities have been loaded and stored
// * executing: Automation execution are currently running
// * monitoring: All executions have been started, now monitoring their completion
// * send_report: Automation executions finished running. Report is being created & sent to the user who initiated the bulk trigger automation
// * finished: Automation executions finished running. Some may have failed. Check the status of each entity.
// * failed: Bulk trigger automation execution failed. Some executions might have started. Check the status of each entity.
// * cancelled: Bulk trigger automation execution was cancelled
type Status string

const (
	StatusApproval         Status = "approval"
	StatusQueryingEntities Status = "querying_entities"
	StatusEntitiesLoaded   Status = "entities_loaded"
	StatusExecuting        Status = "executing"
	StatusMonitoring       Status = "monitoring"
	StatusSendReport       Status = "send_report"
	StatusFinished         Status = "finished"
	StatusFailed           Status = "failed"
	StatusCancelled        Status = "cancelled"
)

func (e Status) ToPointer() *Status {
	return &e
}
func (e *Status) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "approval":
		fallthrough
	case "querying_entities":
		fallthrough
	case "entities_loaded":
		fallthrough
	case "executing":
		fallthrough
	case "monitoring":
		fallthrough
	case "send_report":
		fallthrough
	case "finished":
		fallthrough
	case "failed":
		fallthrough
	case "cancelled":
		*e = Status(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Status: %v", v)
	}
}

type BulkTriggerJob struct {
	// Time when the bulk trigger automation executions job was approved
	ApprovedAt *time.Time `json:"approved_at,omitempty"`
	CreatedAt  time.Time  `json:"created_at"`
	// User ID who created the bulk trigger automation job
	CreatedBy string `json:"created_by"`
	// Query configuration for loading entities
	EntityQuery *EntityQuery `json:"entity_query,omitempty"`
	// List of entities & their automation execution id & status
	ExecutionSummary []ExecItem `json:"execution_summary,omitempty"`
	// ID of the Automation Flow
	FlowID string `json:"flow_id"`
	// Job ID for tracking the status of bulk trigger automation executions
	JobID string `json:"job_id"`
	OrgID string `json:"org_id"`
	// Pagination state for entity loading
	PaginationState *PaginationState `json:"pagination_state,omitempty"`
	// Entity ID of the report file entity
	ReportFileEntityID *string `json:"report_file_entity_id,omitempty"`
	// Status of the bulk trigger automation job
	// * approval: Waiting for user approval to start the bulk trigger automation
	// * querying_entities: Loading entities in batches
	// * entities_loaded: All entities have been loaded and stored
	// * executing: Automation execution are currently running
	// * monitoring: All executions have been started, now monitoring their completion
	// * send_report: Automation executions finished running. Report is being created & sent to the user who initiated the bulk trigger automation
	// * finished: Automation executions finished running. Some may have failed. Check the status of each entity.
	// * failed: Bulk trigger automation execution failed. Some executions might have started. Check the status of each entity.
	// * cancelled: Bulk trigger automation execution was cancelled
	//
	Status Status `json:"status"`
	// Task token to approve/cancel the bulk automation job
	TaskToken *string `json:"task_token,omitempty"`
	// Additional contextual data for a bulk trigger automation. This would normally include additional entity IDs you'd need after a listener picks up an event.
	TriggerContext map[string]string `json:"trigger_context,omitempty"`
	UpdatedAt      time.Time         `json:"updated_at"`
}

func (b BulkTriggerJob) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BulkTriggerJob) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (b *BulkTriggerJob) GetApprovedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.ApprovedAt
}

func (b *BulkTriggerJob) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *BulkTriggerJob) GetCreatedBy() string {
	if b == nil {
		return ""
	}
	return b.CreatedBy
}

func (b *BulkTriggerJob) GetEntityQuery() *EntityQuery {
	if b == nil {
		return nil
	}
	return b.EntityQuery
}

func (b *BulkTriggerJob) GetExecutionSummary() []ExecItem {
	if b == nil {
		return nil
	}
	return b.ExecutionSummary
}

func (b *BulkTriggerJob) GetFlowID() string {
	if b == nil {
		return ""
	}
	return b.FlowID
}

func (b *BulkTriggerJob) GetJobID() string {
	if b == nil {
		return ""
	}
	return b.JobID
}

func (b *BulkTriggerJob) GetOrgID() string {
	if b == nil {
		return ""
	}
	return b.OrgID
}

func (b *BulkTriggerJob) GetPaginationState() *PaginationState {
	if b == nil {
		return nil
	}
	return b.PaginationState
}

func (b *BulkTriggerJob) GetReportFileEntityID() *string {
	if b == nil {
		return nil
	}
	return b.ReportFileEntityID
}

func (b *BulkTriggerJob) GetStatus() Status {
	if b == nil {
		return Status("")
	}
	return b.Status
}

func (b *BulkTriggerJob) GetTaskToken() *string {
	if b == nil {
		return nil
	}
	return b.TaskToken
}

func (b *BulkTriggerJob) GetTriggerContext() map[string]string {
	if b == nil {
		return nil
	}
	return b.TriggerContext
}

func (b *BulkTriggerJob) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}
