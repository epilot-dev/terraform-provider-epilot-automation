// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"errors"
	"github.com/epilot-dev/terraform-provider-epilot-automation/internal/sdk/pkg/utils"
)

type FilterConditionOnEvent2Type string

const (
	FilterConditionOnEvent2TypeStr                       FilterConditionOnEvent2Type = "str"
	FilterConditionOnEvent2TypeEqualsIgnoreCaseCondition FilterConditionOnEvent2Type = "EqualsIgnoreCaseCondition"
	FilterConditionOnEvent2TypeAnythingButCondition      FilterConditionOnEvent2Type = "AnythingButCondition"
	FilterConditionOnEvent2TypeNumericCondition          FilterConditionOnEvent2Type = "NumericCondition"
	FilterConditionOnEvent2TypeExistsCondition           FilterConditionOnEvent2Type = "ExistsCondition"
	FilterConditionOnEvent2TypePrefixCondition           FilterConditionOnEvent2Type = "PrefixCondition"
	FilterConditionOnEvent2TypeSuffixCondition           FilterConditionOnEvent2Type = "SuffixCondition"
	FilterConditionOnEvent2TypeWildcardCondition         FilterConditionOnEvent2Type = "WildcardCondition"
)

type FilterConditionOnEvent2 struct {
	Str                       *string
	EqualsIgnoreCaseCondition *EqualsIgnoreCaseCondition
	AnythingButCondition      *AnythingButCondition
	NumericCondition          *NumericCondition
	ExistsCondition           *ExistsCondition
	PrefixCondition           *PrefixCondition
	SuffixCondition           *SuffixCondition
	WildcardCondition         *WildcardCondition

	Type FilterConditionOnEvent2Type
}

func CreateFilterConditionOnEvent2Str(str string) FilterConditionOnEvent2 {
	typ := FilterConditionOnEvent2TypeStr

	return FilterConditionOnEvent2{
		Str:  &str,
		Type: typ,
	}
}

func CreateFilterConditionOnEvent2EqualsIgnoreCaseCondition(equalsIgnoreCaseCondition EqualsIgnoreCaseCondition) FilterConditionOnEvent2 {
	typ := FilterConditionOnEvent2TypeEqualsIgnoreCaseCondition

	return FilterConditionOnEvent2{
		EqualsIgnoreCaseCondition: &equalsIgnoreCaseCondition,
		Type:                      typ,
	}
}

func CreateFilterConditionOnEvent2AnythingButCondition(anythingButCondition AnythingButCondition) FilterConditionOnEvent2 {
	typ := FilterConditionOnEvent2TypeAnythingButCondition

	return FilterConditionOnEvent2{
		AnythingButCondition: &anythingButCondition,
		Type:                 typ,
	}
}

func CreateFilterConditionOnEvent2NumericCondition(numericCondition NumericCondition) FilterConditionOnEvent2 {
	typ := FilterConditionOnEvent2TypeNumericCondition

	return FilterConditionOnEvent2{
		NumericCondition: &numericCondition,
		Type:             typ,
	}
}

func CreateFilterConditionOnEvent2ExistsCondition(existsCondition ExistsCondition) FilterConditionOnEvent2 {
	typ := FilterConditionOnEvent2TypeExistsCondition

	return FilterConditionOnEvent2{
		ExistsCondition: &existsCondition,
		Type:            typ,
	}
}

func CreateFilterConditionOnEvent2PrefixCondition(prefixCondition PrefixCondition) FilterConditionOnEvent2 {
	typ := FilterConditionOnEvent2TypePrefixCondition

	return FilterConditionOnEvent2{
		PrefixCondition: &prefixCondition,
		Type:            typ,
	}
}

func CreateFilterConditionOnEvent2SuffixCondition(suffixCondition SuffixCondition) FilterConditionOnEvent2 {
	typ := FilterConditionOnEvent2TypeSuffixCondition

	return FilterConditionOnEvent2{
		SuffixCondition: &suffixCondition,
		Type:            typ,
	}
}

func CreateFilterConditionOnEvent2WildcardCondition(wildcardCondition WildcardCondition) FilterConditionOnEvent2 {
	typ := FilterConditionOnEvent2TypeWildcardCondition

	return FilterConditionOnEvent2{
		WildcardCondition: &wildcardCondition,
		Type:              typ,
	}
}

func (u *FilterConditionOnEvent2) UnmarshalJSON(data []byte) error {

	equalsIgnoreCaseCondition := new(EqualsIgnoreCaseCondition)
	if err := utils.UnmarshalJSON(data, &equalsIgnoreCaseCondition, "", true, true); err == nil {
		u.EqualsIgnoreCaseCondition = equalsIgnoreCaseCondition
		u.Type = FilterConditionOnEvent2TypeEqualsIgnoreCaseCondition
		return nil
	}

	anythingButCondition := new(AnythingButCondition)
	if err := utils.UnmarshalJSON(data, &anythingButCondition, "", true, true); err == nil {
		u.AnythingButCondition = anythingButCondition
		u.Type = FilterConditionOnEvent2TypeAnythingButCondition
		return nil
	}

	numericCondition := new(NumericCondition)
	if err := utils.UnmarshalJSON(data, &numericCondition, "", true, true); err == nil {
		u.NumericCondition = numericCondition
		u.Type = FilterConditionOnEvent2TypeNumericCondition
		return nil
	}

	existsCondition := new(ExistsCondition)
	if err := utils.UnmarshalJSON(data, &existsCondition, "", true, true); err == nil {
		u.ExistsCondition = existsCondition
		u.Type = FilterConditionOnEvent2TypeExistsCondition
		return nil
	}

	prefixCondition := new(PrefixCondition)
	if err := utils.UnmarshalJSON(data, &prefixCondition, "", true, true); err == nil {
		u.PrefixCondition = prefixCondition
		u.Type = FilterConditionOnEvent2TypePrefixCondition
		return nil
	}

	suffixCondition := new(SuffixCondition)
	if err := utils.UnmarshalJSON(data, &suffixCondition, "", true, true); err == nil {
		u.SuffixCondition = suffixCondition
		u.Type = FilterConditionOnEvent2TypeSuffixCondition
		return nil
	}

	wildcardCondition := new(WildcardCondition)
	if err := utils.UnmarshalJSON(data, &wildcardCondition, "", true, true); err == nil {
		u.WildcardCondition = wildcardCondition
		u.Type = FilterConditionOnEvent2TypeWildcardCondition
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = FilterConditionOnEvent2TypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u FilterConditionOnEvent2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.EqualsIgnoreCaseCondition != nil {
		return utils.MarshalJSON(u.EqualsIgnoreCaseCondition, "", true)
	}

	if u.AnythingButCondition != nil {
		return utils.MarshalJSON(u.AnythingButCondition, "", true)
	}

	if u.NumericCondition != nil {
		return utils.MarshalJSON(u.NumericCondition, "", true)
	}

	if u.ExistsCondition != nil {
		return utils.MarshalJSON(u.ExistsCondition, "", true)
	}

	if u.PrefixCondition != nil {
		return utils.MarshalJSON(u.PrefixCondition, "", true)
	}

	if u.SuffixCondition != nil {
		return utils.MarshalJSON(u.SuffixCondition, "", true)
	}

	if u.WildcardCondition != nil {
		return utils.MarshalJSON(u.WildcardCondition, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type FilterConditionOnEventType string

const (
	FilterConditionOnEventTypeOrCondition                         FilterConditionOnEventType = "OrCondition"
	FilterConditionOnEventTypeMapOfarrayOfFilterConditionOnEvent2 FilterConditionOnEventType = "mapOfarrayOfFilterConditionOnEvent_2"
)

type FilterConditionOnEvent struct {
	OrCondition                         *OrCondition
	MapOfarrayOfFilterConditionOnEvent2 map[string][]FilterConditionOnEvent2

	Type FilterConditionOnEventType
}

func CreateFilterConditionOnEventOrCondition(orCondition OrCondition) FilterConditionOnEvent {
	typ := FilterConditionOnEventTypeOrCondition

	return FilterConditionOnEvent{
		OrCondition: &orCondition,
		Type:        typ,
	}
}

func CreateFilterConditionOnEventMapOfarrayOfFilterConditionOnEvent2(mapOfarrayOfFilterConditionOnEvent2 map[string][]FilterConditionOnEvent2) FilterConditionOnEvent {
	typ := FilterConditionOnEventTypeMapOfarrayOfFilterConditionOnEvent2

	return FilterConditionOnEvent{
		MapOfarrayOfFilterConditionOnEvent2: mapOfarrayOfFilterConditionOnEvent2,
		Type:                                typ,
	}
}

func (u *FilterConditionOnEvent) UnmarshalJSON(data []byte) error {

	orCondition := new(OrCondition)
	if err := utils.UnmarshalJSON(data, &orCondition, "", true, true); err == nil {
		u.OrCondition = orCondition
		u.Type = FilterConditionOnEventTypeOrCondition
		return nil
	}

	mapOfarrayOfFilterConditionOnEvent2 := map[string][]FilterConditionOnEvent2{}
	if err := utils.UnmarshalJSON(data, &mapOfarrayOfFilterConditionOnEvent2, "", true, true); err == nil {
		u.MapOfarrayOfFilterConditionOnEvent2 = mapOfarrayOfFilterConditionOnEvent2
		u.Type = FilterConditionOnEventTypeMapOfarrayOfFilterConditionOnEvent2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u FilterConditionOnEvent) MarshalJSON() ([]byte, error) {
	if u.OrCondition != nil {
		return utils.MarshalJSON(u.OrCondition, "", true)
	}

	if u.MapOfarrayOfFilterConditionOnEvent2 != nil {
		return utils.MarshalJSON(u.MapOfarrayOfFilterConditionOnEvent2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}
