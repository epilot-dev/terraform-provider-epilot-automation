// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"errors"
	"github.com/epilot-dev/terraform-provider-epilot-automation/internal/sdk/pkg/utils"
)

type DiffDeleted2Type string

const (
	DiffDeleted2TypeStr                       DiffDeleted2Type = "str"
	DiffDeleted2TypeEqualsIgnoreCaseCondition DiffDeleted2Type = "EqualsIgnoreCaseCondition"
	DiffDeleted2TypeAnythingButCondition      DiffDeleted2Type = "AnythingButCondition"
	DiffDeleted2TypeNumericCondition          DiffDeleted2Type = "NumericCondition"
	DiffDeleted2TypeExistsCondition           DiffDeleted2Type = "ExistsCondition"
	DiffDeleted2TypePrefixCondition           DiffDeleted2Type = "PrefixCondition"
	DiffDeleted2TypeSuffixCondition           DiffDeleted2Type = "SuffixCondition"
	DiffDeleted2TypeWildcardCondition         DiffDeleted2Type = "WildcardCondition"
)

type DiffDeleted2 struct {
	Str                       *string
	EqualsIgnoreCaseCondition *EqualsIgnoreCaseCondition
	AnythingButCondition      *AnythingButCondition
	NumericCondition          *NumericCondition
	ExistsCondition           *ExistsCondition
	PrefixCondition           *PrefixCondition
	SuffixCondition           *SuffixCondition
	WildcardCondition         *WildcardCondition

	Type DiffDeleted2Type
}

func CreateDiffDeleted2Str(str string) DiffDeleted2 {
	typ := DiffDeleted2TypeStr

	return DiffDeleted2{
		Str:  &str,
		Type: typ,
	}
}

func CreateDiffDeleted2EqualsIgnoreCaseCondition(equalsIgnoreCaseCondition EqualsIgnoreCaseCondition) DiffDeleted2 {
	typ := DiffDeleted2TypeEqualsIgnoreCaseCondition

	return DiffDeleted2{
		EqualsIgnoreCaseCondition: &equalsIgnoreCaseCondition,
		Type:                      typ,
	}
}

func CreateDiffDeleted2AnythingButCondition(anythingButCondition AnythingButCondition) DiffDeleted2 {
	typ := DiffDeleted2TypeAnythingButCondition

	return DiffDeleted2{
		AnythingButCondition: &anythingButCondition,
		Type:                 typ,
	}
}

func CreateDiffDeleted2NumericCondition(numericCondition NumericCondition) DiffDeleted2 {
	typ := DiffDeleted2TypeNumericCondition

	return DiffDeleted2{
		NumericCondition: &numericCondition,
		Type:             typ,
	}
}

func CreateDiffDeleted2ExistsCondition(existsCondition ExistsCondition) DiffDeleted2 {
	typ := DiffDeleted2TypeExistsCondition

	return DiffDeleted2{
		ExistsCondition: &existsCondition,
		Type:            typ,
	}
}

func CreateDiffDeleted2PrefixCondition(prefixCondition PrefixCondition) DiffDeleted2 {
	typ := DiffDeleted2TypePrefixCondition

	return DiffDeleted2{
		PrefixCondition: &prefixCondition,
		Type:            typ,
	}
}

func CreateDiffDeleted2SuffixCondition(suffixCondition SuffixCondition) DiffDeleted2 {
	typ := DiffDeleted2TypeSuffixCondition

	return DiffDeleted2{
		SuffixCondition: &suffixCondition,
		Type:            typ,
	}
}

func CreateDiffDeleted2WildcardCondition(wildcardCondition WildcardCondition) DiffDeleted2 {
	typ := DiffDeleted2TypeWildcardCondition

	return DiffDeleted2{
		WildcardCondition: &wildcardCondition,
		Type:              typ,
	}
}

func (u *DiffDeleted2) UnmarshalJSON(data []byte) error {

	equalsIgnoreCaseCondition := new(EqualsIgnoreCaseCondition)
	if err := utils.UnmarshalJSON(data, &equalsIgnoreCaseCondition, "", true, true); err == nil {
		u.EqualsIgnoreCaseCondition = equalsIgnoreCaseCondition
		u.Type = DiffDeleted2TypeEqualsIgnoreCaseCondition
		return nil
	}

	anythingButCondition := new(AnythingButCondition)
	if err := utils.UnmarshalJSON(data, &anythingButCondition, "", true, true); err == nil {
		u.AnythingButCondition = anythingButCondition
		u.Type = DiffDeleted2TypeAnythingButCondition
		return nil
	}

	numericCondition := new(NumericCondition)
	if err := utils.UnmarshalJSON(data, &numericCondition, "", true, true); err == nil {
		u.NumericCondition = numericCondition
		u.Type = DiffDeleted2TypeNumericCondition
		return nil
	}

	existsCondition := new(ExistsCondition)
	if err := utils.UnmarshalJSON(data, &existsCondition, "", true, true); err == nil {
		u.ExistsCondition = existsCondition
		u.Type = DiffDeleted2TypeExistsCondition
		return nil
	}

	prefixCondition := new(PrefixCondition)
	if err := utils.UnmarshalJSON(data, &prefixCondition, "", true, true); err == nil {
		u.PrefixCondition = prefixCondition
		u.Type = DiffDeleted2TypePrefixCondition
		return nil
	}

	suffixCondition := new(SuffixCondition)
	if err := utils.UnmarshalJSON(data, &suffixCondition, "", true, true); err == nil {
		u.SuffixCondition = suffixCondition
		u.Type = DiffDeleted2TypeSuffixCondition
		return nil
	}

	wildcardCondition := new(WildcardCondition)
	if err := utils.UnmarshalJSON(data, &wildcardCondition, "", true, true); err == nil {
		u.WildcardCondition = wildcardCondition
		u.Type = DiffDeleted2TypeWildcardCondition
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = DiffDeleted2TypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DiffDeleted2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.EqualsIgnoreCaseCondition != nil {
		return utils.MarshalJSON(u.EqualsIgnoreCaseCondition, "", true)
	}

	if u.AnythingButCondition != nil {
		return utils.MarshalJSON(u.AnythingButCondition, "", true)
	}

	if u.NumericCondition != nil {
		return utils.MarshalJSON(u.NumericCondition, "", true)
	}

	if u.ExistsCondition != nil {
		return utils.MarshalJSON(u.ExistsCondition, "", true)
	}

	if u.PrefixCondition != nil {
		return utils.MarshalJSON(u.PrefixCondition, "", true)
	}

	if u.SuffixCondition != nil {
		return utils.MarshalJSON(u.SuffixCondition, "", true)
	}

	if u.WildcardCondition != nil {
		return utils.MarshalJSON(u.WildcardCondition, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DiffDeletedType string

const (
	DiffDeletedTypeOrCondition1             DiffDeletedType = "OrCondition1"
	DiffDeletedTypeMapOfarrayOfDiffDeleted2 DiffDeletedType = "mapOfarrayOfDiffDeleted_2"
)

type DiffDeleted struct {
	OrCondition1             *OrCondition1
	MapOfarrayOfDiffDeleted2 map[string][]DiffDeleted2

	Type DiffDeletedType
}

func CreateDiffDeletedOrCondition1(orCondition1 OrCondition1) DiffDeleted {
	typ := DiffDeletedTypeOrCondition1

	return DiffDeleted{
		OrCondition1: &orCondition1,
		Type:         typ,
	}
}

func CreateDiffDeletedMapOfarrayOfDiffDeleted2(mapOfarrayOfDiffDeleted2 map[string][]DiffDeleted2) DiffDeleted {
	typ := DiffDeletedTypeMapOfarrayOfDiffDeleted2

	return DiffDeleted{
		MapOfarrayOfDiffDeleted2: mapOfarrayOfDiffDeleted2,
		Type:                     typ,
	}
}

func (u *DiffDeleted) UnmarshalJSON(data []byte) error {

	orCondition1 := new(OrCondition1)
	if err := utils.UnmarshalJSON(data, &orCondition1, "", true, true); err == nil {
		u.OrCondition1 = orCondition1
		u.Type = DiffDeletedTypeOrCondition1
		return nil
	}

	mapOfarrayOfDiffDeleted2 := map[string][]DiffDeleted2{}
	if err := utils.UnmarshalJSON(data, &mapOfarrayOfDiffDeleted2, "", true, true); err == nil {
		u.MapOfarrayOfDiffDeleted2 = mapOfarrayOfDiffDeleted2
		u.Type = DiffDeletedTypeMapOfarrayOfDiffDeleted2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DiffDeleted) MarshalJSON() ([]byte, error) {
	if u.OrCondition1 != nil {
		return utils.MarshalJSON(u.OrCondition1, "", true)
	}

	if u.MapOfarrayOfDiffDeleted2 != nil {
		return utils.MarshalJSON(u.MapOfarrayOfDiffDeleted2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}
