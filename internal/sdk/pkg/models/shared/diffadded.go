// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"errors"
	"github.com/epilot-dev/terraform-provider-epilot-automation/internal/sdk/pkg/utils"
)

type TwoType string

const (
	TwoTypeStr                       TwoType = "str"
	TwoTypeEqualsIgnoreCaseCondition TwoType = "EqualsIgnoreCaseCondition"
	TwoTypeAnythingButCondition      TwoType = "AnythingButCondition"
	TwoTypeNumericCondition          TwoType = "NumericCondition"
	TwoTypeExistsCondition           TwoType = "ExistsCondition"
	TwoTypePrefixCondition           TwoType = "PrefixCondition"
	TwoTypeSuffixCondition           TwoType = "SuffixCondition"
	TwoTypeWildcardCondition         TwoType = "WildcardCondition"
)

type Two struct {
	Str                       *string
	EqualsIgnoreCaseCondition *EqualsIgnoreCaseCondition
	AnythingButCondition      *AnythingButCondition
	NumericCondition          *NumericCondition
	ExistsCondition           *ExistsCondition
	PrefixCondition           *PrefixCondition
	SuffixCondition           *SuffixCondition
	WildcardCondition         *WildcardCondition

	Type TwoType
}

func CreateTwoStr(str string) Two {
	typ := TwoTypeStr

	return Two{
		Str:  &str,
		Type: typ,
	}
}

func CreateTwoEqualsIgnoreCaseCondition(equalsIgnoreCaseCondition EqualsIgnoreCaseCondition) Two {
	typ := TwoTypeEqualsIgnoreCaseCondition

	return Two{
		EqualsIgnoreCaseCondition: &equalsIgnoreCaseCondition,
		Type:                      typ,
	}
}

func CreateTwoAnythingButCondition(anythingButCondition AnythingButCondition) Two {
	typ := TwoTypeAnythingButCondition

	return Two{
		AnythingButCondition: &anythingButCondition,
		Type:                 typ,
	}
}

func CreateTwoNumericCondition(numericCondition NumericCondition) Two {
	typ := TwoTypeNumericCondition

	return Two{
		NumericCondition: &numericCondition,
		Type:             typ,
	}
}

func CreateTwoExistsCondition(existsCondition ExistsCondition) Two {
	typ := TwoTypeExistsCondition

	return Two{
		ExistsCondition: &existsCondition,
		Type:            typ,
	}
}

func CreateTwoPrefixCondition(prefixCondition PrefixCondition) Two {
	typ := TwoTypePrefixCondition

	return Two{
		PrefixCondition: &prefixCondition,
		Type:            typ,
	}
}

func CreateTwoSuffixCondition(suffixCondition SuffixCondition) Two {
	typ := TwoTypeSuffixCondition

	return Two{
		SuffixCondition: &suffixCondition,
		Type:            typ,
	}
}

func CreateTwoWildcardCondition(wildcardCondition WildcardCondition) Two {
	typ := TwoTypeWildcardCondition

	return Two{
		WildcardCondition: &wildcardCondition,
		Type:              typ,
	}
}

func (u *Two) UnmarshalJSON(data []byte) error {

	equalsIgnoreCaseCondition := new(EqualsIgnoreCaseCondition)
	if err := utils.UnmarshalJSON(data, &equalsIgnoreCaseCondition, "", true, true); err == nil {
		u.EqualsIgnoreCaseCondition = equalsIgnoreCaseCondition
		u.Type = TwoTypeEqualsIgnoreCaseCondition
		return nil
	}

	anythingButCondition := new(AnythingButCondition)
	if err := utils.UnmarshalJSON(data, &anythingButCondition, "", true, true); err == nil {
		u.AnythingButCondition = anythingButCondition
		u.Type = TwoTypeAnythingButCondition
		return nil
	}

	numericCondition := new(NumericCondition)
	if err := utils.UnmarshalJSON(data, &numericCondition, "", true, true); err == nil {
		u.NumericCondition = numericCondition
		u.Type = TwoTypeNumericCondition
		return nil
	}

	existsCondition := new(ExistsCondition)
	if err := utils.UnmarshalJSON(data, &existsCondition, "", true, true); err == nil {
		u.ExistsCondition = existsCondition
		u.Type = TwoTypeExistsCondition
		return nil
	}

	prefixCondition := new(PrefixCondition)
	if err := utils.UnmarshalJSON(data, &prefixCondition, "", true, true); err == nil {
		u.PrefixCondition = prefixCondition
		u.Type = TwoTypePrefixCondition
		return nil
	}

	suffixCondition := new(SuffixCondition)
	if err := utils.UnmarshalJSON(data, &suffixCondition, "", true, true); err == nil {
		u.SuffixCondition = suffixCondition
		u.Type = TwoTypeSuffixCondition
		return nil
	}

	wildcardCondition := new(WildcardCondition)
	if err := utils.UnmarshalJSON(data, &wildcardCondition, "", true, true); err == nil {
		u.WildcardCondition = wildcardCondition
		u.Type = TwoTypeWildcardCondition
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = TwoTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Two) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.EqualsIgnoreCaseCondition != nil {
		return utils.MarshalJSON(u.EqualsIgnoreCaseCondition, "", true)
	}

	if u.AnythingButCondition != nil {
		return utils.MarshalJSON(u.AnythingButCondition, "", true)
	}

	if u.NumericCondition != nil {
		return utils.MarshalJSON(u.NumericCondition, "", true)
	}

	if u.ExistsCondition != nil {
		return utils.MarshalJSON(u.ExistsCondition, "", true)
	}

	if u.PrefixCondition != nil {
		return utils.MarshalJSON(u.PrefixCondition, "", true)
	}

	if u.SuffixCondition != nil {
		return utils.MarshalJSON(u.SuffixCondition, "", true)
	}

	if u.WildcardCondition != nil {
		return utils.MarshalJSON(u.WildcardCondition, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DiffAddedType string

const (
	DiffAddedTypeOrCondition1  DiffAddedType = "OrCondition1"
	DiffAddedTypeMapOfarrayOf2 DiffAddedType = "mapOfarrayOf2"
)

type DiffAdded struct {
	OrCondition1  *OrCondition1
	MapOfarrayOf2 map[string][]Two

	Type DiffAddedType
}

func CreateDiffAddedOrCondition1(orCondition1 OrCondition1) DiffAdded {
	typ := DiffAddedTypeOrCondition1

	return DiffAdded{
		OrCondition1: &orCondition1,
		Type:         typ,
	}
}

func CreateDiffAddedMapOfarrayOf2(mapOfarrayOf2 map[string][]Two) DiffAdded {
	typ := DiffAddedTypeMapOfarrayOf2

	return DiffAdded{
		MapOfarrayOf2: mapOfarrayOf2,
		Type:          typ,
	}
}

func (u *DiffAdded) UnmarshalJSON(data []byte) error {

	orCondition1 := new(OrCondition1)
	if err := utils.UnmarshalJSON(data, &orCondition1, "", true, true); err == nil {
		u.OrCondition1 = orCondition1
		u.Type = DiffAddedTypeOrCondition1
		return nil
	}

	mapOfarrayOf2 := map[string][]Two{}
	if err := utils.UnmarshalJSON(data, &mapOfarrayOf2, "", true, true); err == nil {
		u.MapOfarrayOf2 = mapOfarrayOf2
		u.Type = DiffAddedTypeMapOfarrayOf2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DiffAdded) MarshalJSON() ([]byte, error) {
	if u.OrCondition1 != nil {
		return utils.MarshalJSON(u.OrCondition1, "", true)
	}

	if u.MapOfarrayOf2 != nil {
		return utils.MarshalJSON(u.MapOfarrayOf2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}
